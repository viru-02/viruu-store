<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Website Auditor — Static</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; }
    pre { white-space: pre-wrap; }
  </style>
</head>
<body class="bg-slate-50 p-6">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-2xl font-bold mb-2">Website Auditor — Static (GitHub Pages)</h1>
    <p class="text-sm text-slate-600 mb-4">Paste a URL and this static page will try to audit basic issues (title, meta, viewport, canonical, sitemap, robots and basic broken-link checks). Some sites block cross-origin requests — enable the CORS proxy option if you face issues.</p>

    <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-4">
      <input id="url" class="col-span-2 p-3 border rounded" placeholder="https://example.com" />
      <button id="run" class="px-4 py-3 bg-blue-600 text-white rounded">Run Audit</button>
      <label class="flex items-center gap-2 col-span-3">
        <input id="useProxy" type="checkbox" />
        <span class="text-sm">Use public CORS proxy (helps when target blocks CORS). <span class="text-xs text-slate-500">(uses https://api.allorigins.win)</span></span>
      </label>
    </div>

    <div id="output" class="bg-white p-4 rounded border min-h-[200px] text-sm text-slate-700 overflow-auto"></div>

    <details class="mt-4 text-xs text-slate-500">
      <summary class="cursor-pointer">Notes / Limitations</summary>
      <ul class="mt-2 pl-4 list-disc">
        <li>Because this is <strong>static frontend</strong>, some checks (DNS, TLS certificate details, server headers blocked by CORS) are not available from the browser.</li>
        <li>If direct fetch fails due to CORS, enable <em>Use public CORS proxy</em>. Public proxies have rate limits and reliability limits — for production use host your own proxy or use a backend.</li>
        <li>Broken link checks are limited (first 50 links) and use the same-origin / proxy rules.</li>
      </ul>
    </details>

  </div>

  <script>
    const out = document.getElementById('output');
    const run = document.getElementById('run');
    const input = document.getElementById('url');
    const useProxyEl = document.getElementById('useProxy');

    function write(x) { out.innerHTML += x + '\n'; out.scrollTop = out.scrollHeight; }
    function clear() { out.innerHTML = ''; }

    function normalize(v) {
      try {
        let u = v.trim();
        if (!/^https?:\/\//i.test(u)) u = 'https://' + u;
        return new URL(u).toString();
      } catch (e) { return null; }
    }

    // public CORS proxy (uses AllOrigins)
    function proxyUrl(u) {
      return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(u);
    }

    async function fetchWithOptionalProxy(url, useProxy) {
      try {
        const res = await fetch(url, { method: 'GET', redirect: 'follow' });
        if (!res.ok) throw new Error('status ' + res.status);
        return { ok:true, text: await res.text(), finalUrl: res.url, status: res.status, headers: res.headers };
      } catch (e) {
        if (!useProxy) throw e;
        // try via proxy
        const purl = proxyUrl(url);
        const res2 = await fetch(purl, { method: 'GET', redirect: 'follow' });
        if (!res2.ok) throw new Error('proxy status ' + res2.status);
        return { ok:true, text: await res2.text(), finalUrl: res2.url, status: res2.status, headers: res2.headers, viaProxy: true };
      }
    }

    async function audit(url, useProxy=false) {
      clear();
      write('Starting audit for: ' + url);
      write('Timestamp: ' + new Date().toLocaleString());

      // 1) Try HEAD to get status quickly (may fail due to CORS)
      try {
        write('\n-> Checking HTTP status...');
        let headRes;
        try {
          headRes = await fetch(url, { method: 'HEAD', redirect: 'follow' });
          write('   HEAD status: ' + headRes.status + ' ' + headRes.statusText + ' (final: ' + headRes.url + ')');
        } catch (e) {
          write('   HEAD request failed (CORS or blocked). Will fallback to GET.');
        }
      } catch (e) { write('   HTTP status check error: ' + e.message); }

      // 2) Fetch HTML (direct or via proxy)
      write('\n-> Fetching HTML (this may be blocked by CORS on some sites)...');
      let htmlText = '';
      let finalUrl = url;
      try {
        const r = await fetchWithOptionalProxy(url, useProxy);
        htmlText = r.text;
        finalUrl = r.finalUrl || finalUrl;
        write('   Fetched OK (status: ' + (r.status || 'unknown') + ') ' + (r.viaProxy ? '[via proxy]' : ''));
      } catch (e) {
        write('   Fetch error: ' + e.message);
        write('\nAudit stopped: could not retrieve HTML. Try enabling the CORS proxy checkbox and run again.');
        return;
      }

      // 3) Parse HTML
      try {
        write('\n-> Parsing HTML...');
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlText, 'text/html');
        const title = (doc.querySelector('title') || { textContent: '' }).textContent.trim();
        const metaDesc = (doc.querySelector('meta[name="description"]') || { getAttribute: ()=>'' }).getAttribute('content') || '';
        const viewport = (doc.querySelector('meta[name="viewport"]') || { getAttribute: ()=>'' }).getAttribute('content') || '';
        const canonical = (doc.querySelector('link[rel="canonical"]') || { getAttribute: ()=>'' }).getAttribute('href') || '';
        const h1count = doc.querySelectorAll('h1').length;

        write('   Title: ' + (title || '[missing]'));
        write('   Meta description: ' + (metaDesc || '[missing]'));
        write('   Viewport: ' + (viewport || '[missing]'));
        write('   Canonical: ' + (canonical || '[missing]'));
        write('   H1 count: ' + h1count);

        if (!title) write('   ISSUE: Missing <title> tag');
        if (!metaDesc) write('   ISSUE: Missing meta description');
        if (!viewport) write('   ISSUE: Missing viewport meta tag - may not be mobile-friendly');

        // robots and sitemap
        write('\n-> Checking robots.txt and sitemap.xml (may be blocked by CORS)');
        try {
          const u = new URL(finalUrl);
          const robots = u.origin + '/robots.txt';
          const sitemap = u.origin + '/sitemap.xml';
          try {
            const r1 = await fetchWithOptionalProxy(robots, useProxy);
            write('   robots.txt: OK (fetched)');
          } catch (e) { write('   robots.txt: not accessible (' + e.message + ')'); }
          try {
            const r2 = await fetchWithOptionalProxy(sitemap, useProxy);
            write('   sitemap.xml: OK (fetched)');
          } catch (e) { write('   sitemap.xml: not accessible (' + e.message + ')'); }
        } catch (e) { write('   robots/sitemap check error: ' + e.message); }

        // collect links
        write('\n-> Collecting links (first 50) and checking status (may be slow)...');
        const anchors = Array.from(doc.querySelectorAll('a[href]')).map(a=>a.getAttribute('href')).filter(Boolean);
        write('   Found ' + anchors.length + ' anchors; checking up to 50 links...');
        const toCheck = anchors.slice(0,50);
        const broken = [];
        for (let i=0;i<toCheck.length;i++) {
          const raw = toCheck[i];
          // ignore anchors and mailto
          if (/^(javascript:|mailto:|#)/i.test(raw)) continue;
          let link;
          try { link = new URL(raw, finalUrl).toString(); } catch (e) { continue; }
          write('     Checking: ' + link);
          try {
            // try HEAD first
            let status = null;
            try {
              const h = await fetch(link, { method: 'HEAD', redirect: 'follow' });
              status = h.status;
            } catch (e) {
              // fallback to GET via optional proxy
              if (!useProxy) {
                write('       HEAD failed (CORS). Skipping or enable proxy to check.');
                continue;
              }
              const rr = await fetchWithOptionalProxy(link, useProxy);
              status = rr.status || 200;
            }
            if (status >= 400 || status < 200) { broken.push({ link, status }); write('       -> BROKEN (status ' + status + ')'); }
            else write('       -> OK (status ' + status + ')');
          } catch (e) { broken.push({ link, status: 'error' }); write('       -> ERROR (' + e.message + ')'); }
        }
        write('\n   Broken links found: ' + broken.length);
        if (broken.length) broken.slice(0,20).forEach(b => write('     - ' + b.link + ' -> ' + b.status));

      } catch (e) { write('   HTML parse/checks error: ' + e.message); }

      write('\nAudit finished.');
    }

    run.addEventListener('click', async () => {
      const raw = input.value;
      const normalized = normalize(raw);
      if (!normalized) { alert('Please enter a valid URL'); return; }
      const useProxy = useProxyEl.checked;
      await audit(normalized, useProxy);
    });

    // allow Enter to trigger
    input.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') run.click(); });
  </script>
</body>
</html>
